/**
 * Script de migration COMPLET pour r√©cup√©rer les attaques de TOUTES les cartes
 *
 * Am√©liorations par rapport √† migrate-attacks.mjs :
 * - Pagination pour r√©cup√©rer TOUTES les cartes (pas de limite 1000)
 * - Sauvegarde de progression pour reprendre en cas d'interruption
 * - Logs d√©taill√©s avec statistiques en temps r√©el
 *
 * Usage:
 *   node migrate-attacks-full.mjs
 */

import { createClient } from '@supabase/supabase-js'
import dotenv from 'dotenv'
import fs from 'fs'

dotenv.config()

// Configuration Supabase
const supabaseUrl = process.env.VITE_SUPABASE_URL
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.VITE_SUPABASE_ANON_KEY

if (!supabaseUrl || !supabaseKey) {
  console.error('‚ùå Erreur: Variables d\'environnement manquantes')
  console.error('   V√©rifiez que VITE_SUPABASE_URL et SUPABASE_SERVICE_ROLE_KEY sont dans .env')
  process.exit(1)
}

const supabase = createClient(supabaseUrl, supabaseKey)

// Fichier de sauvegarde de progression
const PROGRESS_FILE = 'migrate-attacks-progress.json'

/**
 * Charger la progression sauvegard√©e
 */
function loadProgress() {
  try {
    if (fs.existsSync(PROGRESS_FILE)) {
      const data = fs.readFileSync(PROGRESS_FILE, 'utf8')
      return JSON.parse(data)
    }
  } catch (error) {
    console.warn('‚ö†Ô∏è Impossible de charger la progression:', error.message)
  }
  return { processedIds: [], successCount: 0, errorCount: 0, notFoundCount: 0 }
}

/**
 * Sauvegarder la progression
 */
function saveProgress(progress) {
  try {
    fs.writeFileSync(PROGRESS_FILE, JSON.stringify(progress, null, 2))
  } catch (error) {
    console.warn('‚ö†Ô∏è Impossible de sauvegarder la progression:', error.message)
  }
}

/**
 * R√©cup√©rer TOUTES les cartes depuis Supabase avec pagination
 */
async function fetchAllCards() {
  console.log('üì• R√©cup√©ration de TOUTES les cartes depuis Supabase...')

  let allCards = []
  let page = 0
  const pageSize = 1000
  let hasMore = true

  while (hasMore) {
    const { data, error } = await supabase
      .from('discovered_cards')
      .select('id, user_id, name, number, set, attacks')
      .range(page * pageSize, (page + 1) * pageSize - 1)

    if (error) {
      throw error
    }

    if (data && data.length > 0) {
      allCards = allCards.concat(data)
      console.log(`  üì¶ Page ${page + 1}: ${data.length} cartes (total: ${allCards.length})`)
      page++
      hasMore = data.length === pageSize
    } else {
      hasMore = false
    }
  }

  console.log(`‚úÖ ${allCards.length} cartes r√©cup√©r√©es au total\n`)
  return allCards
}

/**
 * R√©cup√©rer les donn√©es d'une carte depuis l'API Pokemon TCG
 */
async function fetchCardFromAPI(cardId) {
  try {
    const response = await fetch(`https://api.pokemontcg.io/v2/cards/${cardId}`, {
      headers: {
        'X-Api-Key': process.env.VITE_POKEMON_TCG_API_KEY || ''
      }
    })

    if (!response.ok) {
      if (response.status === 404) {
        return null // Carte non trouv√©e
      }
      throw new Error(`HTTP ${response.status}: ${response.statusText}`)
    }

    const data = await response.json()
    return data.data
  } catch (error) {
    console.error(`‚ùå Erreur fetch API pour ${cardId}:`, error.message)
    return null
  }
}

/**
 * Fonction principale de migration
 */
async function main() {
  console.log('\nüöÄ D√©but migration COMPL√àTE des attaques...\n')
  console.log('‚ö†Ô∏è  Ce script va traiter TOUTES les cartes (peut prendre plusieurs heures)\n')

  const startTime = Date.now()

  try {
    // 1. Charger la progression pr√©c√©dente
    const progress = loadProgress()
    console.log(`üìÇ Progression charg√©e: ${progress.processedIds.length} cartes d√©j√† trait√©es`)

    // 2. R√©cup√©rer TOUTES les cartes
    const allCards = await fetchAllCards()

    // 3. Filtrer les cartes sans attaques ET non d√©j√† trait√©es
    const cardsWithoutAttacks = allCards.filter(card =>
      (!card.attacks || (Array.isArray(card.attacks) && card.attacks.length === 0)) &&
      !progress.processedIds.includes(card.id)
    )

    console.log(`üìä Statistiques:`)
    console.log(`   Total cartes: ${allCards.length}`)
    console.log(`   Cartes avec attaques: ${allCards.length - allCards.filter(c => !c.attacks || c.attacks.length === 0).length}`)
    console.log(`   Cartes sans attaques: ${allCards.filter(c => !c.attacks || c.attacks.length === 0).length}`)
    console.log(`   D√©j√† trait√©es: ${progress.processedIds.length}`)
    console.log(`   Restantes √† traiter: ${cardsWithoutAttacks.length}`)

    // Estimation du temps
    const batchSize = 5
    const delayBetweenBatches = 2000
    const estimatedBatches = Math.ceil(cardsWithoutAttacks.length / batchSize)
    const estimatedSeconds = (estimatedBatches * delayBetweenBatches) / 1000
    const estimatedMinutes = Math.round(estimatedSeconds / 60)

    console.log(`\n‚è±Ô∏è  Temps estim√©: ~${estimatedMinutes} minutes (${estimatedBatches} batches de ${batchSize} cartes)\n`)

    console.log(`üîÑ D√©but migration de ${cardsWithoutAttacks.length} cartes...\n`)

    let successCount = progress.successCount
    let errorCount = progress.errorCount
    let notFoundCount = progress.notFoundCount

    // 4. Traiter les cartes par batches
    for (let i = 0; i < cardsWithoutAttacks.length; i += batchSize) {
      const batch = cardsWithoutAttacks.slice(i, i + batchSize)

      // Traiter le batch en parall√®le
      const batchPromises = batch.map(async (card) => {
        try {
          // R√©cup√©rer les donn√©es depuis l'API
          const apiCard = await fetchCardFromAPI(card.id)

          if (!apiCard) {
            notFoundCount++
            console.log(`‚ö†Ô∏è  Carte non trouv√©e dans l'API: ${card.name} (${card.id})`)
            progress.processedIds.push(card.id)
            return { success: false, reason: 'not_found' }
          }

          // Extraire les champs manquants
          const updates = {}

          if (apiCard.attacks && apiCard.attacks.length > 0) {
            updates.attacks = apiCard.attacks
          }

          if (apiCard.abilities && apiCard.abilities.length > 0) {
            updates.abilities = apiCard.abilities
          }

          if (apiCard.weaknesses) {
            updates.weaknesses = apiCard.weaknesses
          }

          if (apiCard.resistances) {
            updates.resistances = apiCard.resistances
          }

          if (apiCard.retreatCost) {
            updates.retreat_cost = apiCard.retreatCost
          }

          // Mettre √† jour dans Supabase si on a des donn√©es
          if (Object.keys(updates).length > 0) {
            const { error: updateError } = await supabase
              .from('discovered_cards')
              .update(updates)
              .eq('id', card.id)

            if (updateError) {
              throw updateError
            }

            successCount++
            console.log(`‚úÖ ${card.name} #${card.number} - ${updates.attacks?.length || 0} attaques`)
            progress.processedIds.push(card.id)
            progress.successCount = successCount
            return { success: true }
          } else {
            console.log(`‚è≠Ô∏è  ${card.name} #${card.number} - Aucune donn√©e √† ajouter`)
            progress.processedIds.push(card.id)
            return { success: false, reason: 'no_data' }
          }

        } catch (error) {
          errorCount++
          progress.errorCount = errorCount
          console.error(`‚ùå Erreur ${card.name} #${card.number}:`, error.message)
          // Ne pas ajouter √† processedIds en cas d'erreur pour pouvoir r√©essayer
          return { success: false, reason: 'error', error }
        }
      })

      // Attendre que le batch soit termin√©
      await Promise.all(batchPromises)

      // Progression
      const processed = Math.min(i + batchSize, cardsWithoutAttacks.length)
      const percent = Math.round((processed / cardsWithoutAttacks.length) * 100)
      const totalProcessed = progress.processedIds.length
      const totalPercent = Math.round((totalProcessed / allCards.filter(c => !c.attacks || c.attacks.length === 0).length) * 100)

      console.log(`\nüìä Progression: ${processed}/${cardsWithoutAttacks.length} (${percent}%)`)
      console.log(`üìà Total global: ${totalProcessed} cartes trait√©es (${totalPercent}% de toutes les cartes sans attaques)`)
      console.log(`‚úÖ Succ√®s: ${successCount} | ‚ùå Erreurs: ${errorCount} | ‚ö†Ô∏è  Non trouv√©es: ${notFoundCount}\n`)

      // Sauvegarder la progression tous les 10 batches
      if ((i / batchSize) % 10 === 0) {
        saveProgress(progress)
        console.log(`üíæ Progression sauvegard√©e (${totalProcessed} cartes)\n`)
      }

      // Pause entre les batches (sauf pour le dernier)
      if (i + batchSize < cardsWithoutAttacks.length) {
        console.log(`‚è∏Ô∏è  Pause ${delayBetweenBatches / 1000}s (rate limiting)...`)
        await new Promise(resolve => setTimeout(resolve, delayBetweenBatches))
      }
    }

    // Sauvegarder la progression finale
    saveProgress(progress)

    // 5. Rapport final
    const duration = ((Date.now() - startTime) / 1000 / 60).toFixed(1)

    console.log('\n' + '='.repeat(60))
    console.log('üìä RAPPORT FINAL')
    console.log('='.repeat(60))
    console.log(`‚úÖ Mises √† jour r√©ussies: ${successCount}`)
    console.log(`‚ùå Erreurs: ${errorCount}`)
    console.log(`‚ö†Ô∏è  Cartes non trouv√©es: ${notFoundCount}`)
    console.log(`‚è≠Ô∏è  Ignor√©es (sans donn√©es): ${cardsWithoutAttacks.length - successCount - errorCount - notFoundCount}`)
    console.log(`‚è±Ô∏è  Temps total: ${duration} minutes`)
    console.log('='.repeat(60))

    console.log('\nüéâ Migration termin√©e!')
    console.log(`üíæ Fichier de progression: ${PROGRESS_FILE}`)
    console.log('   Vous pouvez le supprimer si vous voulez recommencer depuis z√©ro\n')

  } catch (error) {
    console.error('\n‚ùå ERREUR CRITIQUE:', error.message)
    console.error(error.stack)

    // Sauvegarder la progression avant de quitter
    saveProgress(progress)
    console.log('\nüíæ Progression sauvegard√©e. Vous pouvez relancer le script pour reprendre.')

    process.exit(1)
  }
}

// Lancer la migration
main()
